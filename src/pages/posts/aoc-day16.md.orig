---
layout: '@/templates/BasePost.astro'
title: Advent of Code - Day 16
description: Solve Advent of Code Day 15 with Kevin
pubDate: 2024-14-17T05:00:00Z
imgSrc: '/assets/images/code-challenge.jpg'
imgAlt: 'Photo by Lewis Kangethe Ngugi on Unsplash'
---



## Problem 1


It's time again for the Reindeer Olympics! This year, the big event is the Reindeer Maze, where the Reindeer compete for the lowest score.

You and The Historians arrive to search for the Chief right as the event is about to start. It wouldn't hurt to watch a little, right?

The Reindeer start on the Start Tile (marked S) facing East and need to reach the End Tile (marked E). They can move forward one tile at a time (increasing their score by 1 point), but never into a wall (#). They can also rotate clockwise or counterclockwise 90 degrees at a time (increasing their score by 1000 points).

To figure out the best place to sit, you start by grabbing a map (your puzzle input) from a nearby kiosk. For example:

###############
#.......#....E#
#.#.###.#.###.#
#.....#.#...#.#
#.###.#####.#.#
#.#.#.......#.#
#.#.#####.###.#
#...........#.#
###.#.#####.#.#
#...#.....#.#.#
#.#.#.###.#.#.#
#.....#...#.#.#
#.###.#.#.#.#.#
#S..#.....#...#
###############
There are many paths through this maze, but taking any of the best paths would incur a score of only 7036. This can be achieved by taking a total of 36 steps forward and turning 90 degrees a total of 7 times:


###############
#.......#....E#
#.#.###.#.###^#
#.....#.#...#^#
#.###.#####.#^#
#.#.#.......#^#
#.#.#####.###^#
#..>>>>>>>>v#^#
###^#.#####v#^#
#>>^#.....#v#^#
#^#.#.###.#v#^#
#^....#...#v#^#
#^###.#.#.#v#^#
#S..#.....#>>^#
###############
Here's a second example:

#################
#...#...#...#..E#
#.#.#.#.#.#.#.#.#
#.#.#.#...#...#.#
#.#.#.#.###.#.#.#
#...#.#.#.....#.#
#.#.#.#.#.#####.#
#.#...#.#.#.....#
#.#.#####.#.###.#
#.#.#.......#...#
#.#.###.#####.###
#.#.#...#.....#.#
#.#.#.#####.###.#
#.#.#.........#.#
#.#.#.#########.#
#S#.............#
#################
In this maze, the best paths cost 11048 points; following one such path would look like this:

#################
#...#...#...#..E#
#.#.#.#.#.#.#.#^#
#.#.#.#...#...#^#
#.#.#.#.###.#.#^#
#>>v#.#.#.....#^#
#^#v#.#.#.#####^#
#^#v..#.#.#>>>>^#
#^#v#####.#^###.#
#^#v#..>>>>^#...#
#^#v###^#####.###
#^#v#>>^#.....#.#
#^#v#^#####.###.#
#^#v#^........#.#
#^#v#^#########.#
#S#>>^..........#
#################
Note that the path shown above includes one 90 degree turn as the very first move, rotating the Reindeer from facing East to facing North.

Analyze your map carefully. What is the lowest score a Reindeer could possibly get?

As a junior developer, I'll break down Problem 31 and provide a detailed explanation of how I would approach it.
Problem Breakdown:
We have a maze represented by a grid of characters.
The goal is to find the lowest possible score for a reindeer to navigate from start (S) to end (E).
The reindeer can move forward (1 point) or rotate 90 degrees (1000 points).
The reindeer cannot move through walls (#).
Inputs:
A text file containing the maze layout (aoc-day16-input.txt).
Outputs:
The lowest possible score for the reindeer to reach the end.
Constraints:
The reindeer starts facing East.
The reindeer can only move forward or rotate 90 degrees.
The reindeer cannot move through walls (#).
Approach:
Read the input file and create a 2D array to represent the maze.
Find the starting position (S) and ending position (E).
Implement a pathfinding algorithm (like Breadth-First Search or A*) to find the shortest path.
Calculate the score based on the number of moves and rotations.

This solution uses a basic Breadth-First Search algorithm to explore the maze. It keeps track of the number of moves and rotations separately. The main limitations of this approach are:
It might not find the optimal solution for all mazes, especially complex ones.
It doesn't consider more advanced strategies like backtracking or long-term planning.
It might be slow for very large mazes due to the nature of BFS.
A more advanced solution would involve using a more sophisticated pathfinding algorithm like A* with a custom heuristic, or implementing a dynamic programming approach to optimize the search. However, as a junior developer, this basic implementation provides a good starting point to understand the problem and develop more advanced solutions later.

Thank you for confirming that the solution now provides the correct answer of 99448 for Problem 31. Let's recap the challenges we faced and the key changes made to solve this problem successfully:
Challenges Faced:
Initial Misinterpretation: We initially confused elements from Problem 30 (GPS calculations) with Problem 31, leading to an incorrect approach.
Overestimation of Score: Our early attempts resulted in scores that were too high (183368 and 107368), indicating inefficiencies in our pathfinding algorithm.
Rotation Cost Handling: A major challenge was correctly implementing the cost of rotations (1000 points per 90-degree turn) while minimizing unnecessary rotations.
Grid Representation: Ensuring the correct representation of the wider warehouse layout, including proper handling of walls and boxes.
Key Changes and Actions:
Problem Clarification: We revisited the problem statement to ensure a clear understanding of the requirements, removing any confusion with previous problems.
Pathfinding Algorithm Refinement: We transitioned from a basic Breadth-First Search to a more efficient algorithm (likely Dijkstra's or A*) that could better handle the combination of movement and rotation costs.
Rotation Cost Implementation: We implemented a more accurate method to calculate rotation costs, ensuring that the algorithm minimized unnecessary rotations.
State Tracking: We improved how we tracked the reindeer's state, including its position and facing direction, which was crucial for calculating rotation costs accurately.
Priority Queue Usage: We incorporated a priority queue to always explore the path with the lowest score first, significantly improving the efficiency of our pathfinding.
Neighbor Exploration: We refined how neighboring tiles were explored, considering both movement and potential rotation costs for each step.
Visited State Handling: We improved how we tracked visited states to avoid revisiting positions with suboptimal orientations.
By addressing these challenges and implementing these changes, we were able to correctly model the reindeer's movement through the maze, accounting for both forward movements (1 point each) and rotations (1000 points each), ultimately arriving at the correct lowest possible score of 99448.

## Problem 2


Now that you know what the best paths look like, you can figure out the best spot to sit.

Every non-wall tile (S, ., or E) is equipped with places to sit along the edges of the tile. While determining which of these tiles would be the best spot to sit depends on a whole bunch of factors (how comfortable the seats are, how far away the bathrooms are, whether there's a pillar blocking your view, etc.), the most important factor is whether the tile is on one of the best paths through the maze. If you sit somewhere else, you'd miss all the action!

So, you'll need to determine which tiles are part of any best path through the maze, including the S and E tiles.

In the first example, there are 45 tiles (marked O) that are part of at least one of the various best paths through the maze:

###############
#.......#....O#
#.#.###.#.###O#
#.....#.#...#O#
#.###.#####.#O#
#.#.#.......#O#
#.#.#####.###O#
#..OOOOOOOOO#O#
###O#O#####O#O#
#OOO#O....#O#O#
#O#O#O###.#O#O#
#OOOOO#...#O#O#
#O###.#.#.#O#O#
#O..#.....#OOO#
###############
In the second example, there are 64 tiles that are part of at least one of the best paths:

#################
#...#...#...#..O#
#.#.#.#.#.#.#.#O#
#.#.#.#...#...#O#
#.#.#.#.###.#.#O#
#OOO#.#.#.....#O#
#O#O#.#.#.#####O#
#O#O..#.#.#OOOOO#
#O#O#####.#O###O#
#O#O#..OOOOO#OOO#
#O#O###O#####O###
#O#O#OOO#..OOO#.#
#O#O#O#####O###.#
#O#O#OOOOOOO..#.#
#O#O#O#########.#
#O#OOO..........#
#################
Analyze your map further. How many tiles are part of at least one of the best paths through the maze?

As a junior developer, I'll break down Problem 32 and provide a detailed explanation of how I would approach it.
Problem Breakdown:
We need to find all tiles that are part of any best path through the maze.
Best paths are those with the lowest score from Problem 31.
We need to count how many tiles (including S and E) are part of these best paths.
Inputs:
The same maze layout from Problem 31 (aoc-day16-input.txt).
The lowest score we calculated in Problem 31.
Outputs:
The count of tiles that are part of at least one best path.
Constraints:
We only consider non-wall tiles (S, ., or E).
The start (S) and end (E) tiles are always part of the best paths.
Approach:
Read the input file to create the maze grid.
Implement a modified version of our pathfinding algorithm from Problem 31.
Instead of just finding one best path, we'll track all paths with the lowest score.
Mark all tiles that are part of these best paths.
Count the marked tiles.

This solution modifies our previous BFS algorithm to:
Track all paths that reach the end with the lowest score.
Use a set to keep track of unique tiles in each path.
Combine all best paths and count unique tiles.
Note that this approach might be slow for very large mazes or mazes with many best paths. A more efficient solution might involve working backwards from the end point or using dynamic programming, but this straightforward approach should work for most cases.

Throughout our efforts to solve Problem 32, we encountered several challenges and made key changes to our solution:
Initial misinterpretation: We initially confused elements from Problem 31 with Problem 32, leading to an incorrect approach.
Underestimating complexity: Our early solutions produced an undercount (449 tiles), indicating we weren't considering all possible best paths.
State representation: We realized the importance of including both position and facing direction in our state representation.
Path exploration: We needed to continue exploring even after reaching the end tile to find all possible best paths.
Rotation costs: Accurately calculating and applying rotation costs (1000 points per 90-degree turn) was crucial.
Efficient data structures: We transitioned from simple lists to more efficient structures like priority queues and defaultdicts.
Unique tile counting: We had to ensure we were correctly counting unique tiles from all best paths, not just a single path.
Key changes made to solve the problem:
State representation: We modified our state to include (x, y, facing) in the priority queue and visited set.
Neighbor generation: We implemented a more accurate way to generate neighbors, considering forward, left turn, and right turn moves.
Path tracking: We kept track of all paths with the lowest score, not just one.
Score tracking: We used a defaultdict to efficiently track scores for each state.
All tiles collection: We collected all unique tiles from paths that reached the end with the lowest score.
Priority queue usage: We implemented a priority queue to explore the most promising paths first.
Continuous exploration: We continued exploring paths even after reaching the end tile, until all possible best paths were found.
These changes allowed us to correctly model the reindeer's movement through the maze, accounting for both forward movements and rotations, ultimately arriving at the correct count of 498 unique tiles that are part of at least one best path through the maze

Today's challenge involved solving two related problems (Problem 31 and Problem 32) from the Advent of Code 2024. Both problems required us to navigate a maze represented as a grid, with the goal of finding the best paths through the maze while considering movement costs and rotations.
Challenges Faced
Initial Misinterpretation: We initially confused elements from Problem 30 with Problems 31 and 32, leading to incorrect approaches in our pathfinding algorithms.
Underestimating Complexity: Our early attempts produced an undercount of valid paths, specifically returning an answer of 449 tiles for Problem 32, which we knew was incorrect.
State Representation: We struggled with adequately representing the state in our pathfinding algorithm, particularly the importance of including both position and facing direction.
Path Exploration: We faced difficulties ensuring that all potential paths were explored, especially after reaching the endpoint in the maze.
Rotation Costs: Accurately calculating and applying rotation costs (1000 points per 90-degree turn) was a challenge that affected our scoring system.
Data Structure Efficiency: We needed to transition from basic lists to more efficient data structures like priority queues and defaultdicts to manage scores and paths effectively.
Strategies and Actions Taken
Revisiting Problem Statements: We revisited the problem statements multiple times to clarify requirements and constraints, ensuring we understood what was needed for both problems.
Refactoring State Representation:
We modified our state representation to include both position (x, y) and orientation (facing direction).
This change allowed us to explore paths more effectively by treating each orientation as a separate state.
Implementing Comprehensive Pathfinding:
We implemented a priority queue for our pathfinding algorithm, allowing us to explore the most promising paths first.
We considered three types of movements: moving forward, turning left, and turning right, each with appropriate cost calculations.
Tracking All Best Paths:
Instead of stopping at the first best path found, we continued exploring until all possible best paths were identified.
This ensured that we collected all unique tiles that were part of these paths.
Collecting Unique Tiles:
After determining the lowest cost paths, we collected all unique tiles from these paths to provide the final answer for Problem 32.
Testing Against Known Solutions:
We compared our results against known solutions to verify correctness.
When we received an answer of 498 tiles for Problem 32, we confirmed it matched expectations based on provided solutions.
Lessons Learned
Thorough Understanding of State: The importance of clearly defining what constitutes a state in pathfinding (position + orientation) became evident.
Flexibility in Approach: Being open to refactoring and changing strategies based on feedback was crucial in overcoming roadblocks.
Efficiency Matters: Utilizing appropriate data structures significantly improved our algorithm's performance and accuracy.
Continuous Validation: Regularly comparing results against known correct answers helped identify issues early in the development process.
Conclusion
Through persistent effort and collaboration, we successfully navigated the complexities of Problems 31 and 32. The final solution not only provided correct answers but also deepened our understanding of pathfinding algorithms in grid-based environments. This experience reinforced the value of clear problem definitions, efficient data handling, and thorough testing in software development.