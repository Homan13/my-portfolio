---
layout: '@/templates/BasePost.astro'
title: Advent of Code - Day 18
description: Solve Advent of Code Day 18 with Kevin
pubDate: 2024-12-19T05:00:00Z
imgSrc: '/assets/images/code-challenge.jpg'
imgAlt: 'Photo by Lewis Kangethe Ngugi on Unsplash'
---





## Problem 1


You and The Historians look a lot more pixelated than you remember. You're inside a computer at the North Pole!

Just as you're about to check out your surroundings, a program runs up to you. "This region of memory isn't safe! The User misunderstood what a pushdown automaton is and their algorithm is pushing whole bytes down on top of us! Run!"

The algorithm is fast - it's going to cause a byte to fall into your memory space once every nanosecond! Fortunately, you're faster, and by quickly scanning the algorithm, you create a list of which bytes will fall (your puzzle input) in the order they'll land in your memory space.

Your memory space is a two-dimensional grid with coordinates that range from 0 to 70 both horizontally and vertically. However, for the sake of example, suppose you're on a smaller grid with coordinates that range from 0 to 6 and the following list of incoming byte positions:

5,4
4,2
4,5
3,0
2,1
6,3
2,4
1,5
0,6
3,3
2,6
5,1
1,2
5,5
2,5
6,5
1,4
0,4
6,4
1,1
6,1
1,0
0,5
1,6
2,0
Each byte position is given as an X,Y coordinate, where X is the distance from the left edge of your memory space and Y is the distance from the top edge of your memory space.

You and The Historians are currently in the top left corner of the memory space (at 0,0) and need to reach the exit in the bottom right corner (at 70,70 in your memory space, but at 6,6 in this example). You'll need to simulate the falling bytes to plan out where it will be safe to run; for now, simulate just the first few bytes falling into your memory space.

As bytes fall into your memory space, they make that coordinate corrupted. Corrupted memory coordinates cannot be entered by you or The Historians, so you'll need to plan your route carefully. You also cannot leave the boundaries of the memory space; your only hope is to reach the exit.

In the above example, if you were to draw the memory space after the first 12 bytes have fallen (using . for safe and # for corrupted), it would look like this:

...#...
..#..#.
....#..
...#..#
..#..#.
.#..#..
#.#....
You can take steps up, down, left, or right. After just 12 bytes have corrupted locations in your memory space, the shortest path from the top left corner to the exit would take 22 steps. Here (marked with O) is one such path:

OO.#OOO
.O#OO#O
.OOO#OO
...#OO#
..#OO#.
.#.O#..
#.#OOOO
Simulate the first kilobyte (1024 bytes) falling onto your memory space. Afterward, what is the minimum number of steps needed to reach the exit?

As a junior developer, I'll break down Problem 35 and provide a detailed explanation of how we might approach it.
Problem Breakdown:
We need to simulate bytes falling into a memory space and find the shortest path from the top-left corner to the bottom-right corner, avoiding corrupted memory locations.
Inputs:
A list of X,Y coordinates representing falling bytes (from the input file).
Memory space size: 71x71 grid (0 to 70 in both dimensions).
Outputs:
The minimum number of steps needed to reach the exit after simulating 1024 bytes falling.
Constraints:
We can only move up, down, left, or right.
We cannot enter corrupted memory locations or leave the boundaries of the memory space.
We need to simulate only the first 1024 bytes falling.
Approach:
Parse the input file to get the list of falling byte coordinates.
Create a 71x71 grid to represent the memory space.
Simulate the first 1024 bytes falling by marking their positions as corrupted.
Use a pathfinding algorithm (like Breadth-First Search) to find the shortest path from (0,0) to (70,70).

This code attempts to solve the problem by:
Parsing the input file to get the list of falling byte coordinates.
Simulating the first 1024 bytes falling onto the grid.
Using a breadth-first search algorithm to find the shortest path from (0,0) to (70,70).
However, as a junior developer, I have some concerns:
Efficiency: The grid is quite large (71x71), and the breadth-first search might be slow for such a large grid.
Memory usage: Storing the entire grid and the visited set might use a lot of memory.
Edge cases: I'm not sure if this handles all possible scenarios, like when there's no valid path to the exit.
It would be helpful to have a senior developer review this approach and suggest optimizations or alternative methods to solve this problem more efficiently.


## Problem 2


The Historians aren't as used to moving around in this pixelated universe as you are. You're afraid they're not going to be fast enough to make it to the exit before the path is completely blocked.

To determine how fast everyone needs to go, you need to determine the first byte that will cut off the path to the exit.

In the above example, after the byte at 1,1 falls, there is still a path to the exit:

O..#OOO
O##OO#O
O#OO#OO
OOO#OO#
###OO##
.##O###
#.#OOOO
However, after adding the very next byte (at 6,1), there is no longer a path to the exit:

...#...
.##..##
.#..#..
...#..#
###..##
.##.###
#.#....
So, in this example, the coordinates of the first byte that prevents the exit from being reachable are 6,1.

Simulate more of the bytes that are about to corrupt your memory space. What are the coordinates of the first byte that will prevent the exit from being reachable from your starting position? (Provide the answer as two integers separated by a comma with no other characters.)

As a junior developer, I'll break down Problem 36 and provide a detailed explanation of how we might approach it.
Problem Breakdown:
We need to find the first byte (coordinate) that, when corrupted, will cut off all paths from the starting position (0,0) to the exit (70,70) in our 71x71 grid.
Inputs:
The same list of X,Y coordinates representing falling bytes from Problem 35.
Memory space size: 71x71 grid (0 to 70 in both dimensions).
Output:
The X,Y coordinates of the first byte that blocks all paths to the exit, separated by a comma.
Constraints:
We can only move up, down, left, or right.
We cannot enter corrupted memory locations or leave the boundaries of the memory space.
We need to check for path availability after each byte falls.
Approach:
Use the same input parsing function from Problem 35.
Create a function to check if a path exists from (0,0) to (70,70) using Breadth-First Search (BFS).
Simulate bytes falling one by one, checking for path availability after each byte falls.
Return the coordinates of the first byte that blocks all paths.

This code attempts to solve the problem by:
Parsing the input file to get the list of falling byte coordinates.
Simulating bytes falling one by one and checking for path availability after each byte falls.
Using a breadth-first search algorithm to check if a path exists from (0,0) to (70,70).
Returning the coordinates of the first byte that blocks all paths.
As a junior developer, I have some concerns:
Efficiency: Checking for path availability after each byte falls might be slow for a large number of bytes.
Memory usage: Creating a new grid for each path check might use a lot of memory.
Edge cases: I'm not sure if this handles all possible scenarios, like when no byte blocks the path.
It would be helpful to have a senior developer review this approach and suggest optimizations or alternative methods to solve this problem more efficiently.
